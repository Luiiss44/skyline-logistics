# Skyline Logistics - Memoria del Proyecto

## Introducción
Skyline Logistics es un juego de simulación logística que pone al jugador al frente de una empresa de transporte y distribución. El objetivo principal es gestionar eficientemente una flota de vehículos para realizar entregas y expandir el negocio, todo mientras se mantiene un balance entre la rentabilidad y la satisfacción del cliente.

El juego se desarrolla en un mundo abierto con múltiples ciudades interconectadas, cada una con sus propias características económicas, geográficas y de demanda. El jugador comenzará con una pequeña empresa local y deberá expandirse gradualmente hasta convertirse en un gigante logístico internacional.

## Objetivo del Juego
El jugador debe convertirse en el líder del mercado logístico, gestionando una red de distribución que conecta diferentes ciudades y puntos de entrega. Para lograrlo, deberá:
- Realizar entregas a tiempo y en perfectas condiciones
- Gestionar eficientemente los recursos económicos
- Mantener y mejorar la flota de vehículos
- Expandir el negocio a nuevas rutas y territorios
- Mantener una buena reputación con los clientes
- Adaptarse a las condiciones del mercado y la competencia
- Gestionar crisis y eventos inesperados
- Optimizar rutas y recursos para maximizar beneficios

## Sistema de Envíos

### Vehículos Disponibles
El juego ofrece una amplia variedad de vehículos, cada uno con características específicas:

#### Furgonetas
- Furgonetas pequeñas (hasta 1.5 toneladas)
  * Ideal para entregas urbanas
  * Bajo consumo de combustible
  * Fácil maniobrabilidad
  * Capacidad limitada
- Furgonetas medianas (hasta 3.5 toneladas)
  * Balance entre capacidad y eficiencia
  * Versatilidad en rutas urbanas e interurbanas
  * Requiere permisos específicos

#### Camiones
- Camiones rígidos (hasta 12 toneladas)
  * Versátiles para rutas medias
  * Buena capacidad de carga
  * Equilibrio entre consumo y rendimiento
- Camiones articulados (hasta 26 toneladas)
  * Alta capacidad de carga
  * Eficientes en largas distancias
  * Requieren experiencia del conductor

#### Tráileres
- Tráileres estándar
  * Máxima capacidad de carga
  * Optimizados para autopistas
  * Requieren infraestructura específica
- Tráileres especializados
  * Refrigerados para productos perecederos
  * Cisternas para líquidos
  * Portacontenedores
  * Plataformas para cargas especiales

### Gestión de Vehículos

#### Sistema de Desgaste
- Desgaste por kilómetro recorrido
- Desgaste por tipo de carga
- Desgaste por condiciones climáticas
- Desgaste por estilo de conducción
- Efectos del desgaste:
  * Mayor consumo de combustible
  * Mayor probabilidad de averías
  * Reducción de velocidad máxima
  * Afecta a la satisfacción del cliente

#### Mantenimiento
- Mantenimiento preventivo
  * Cambios de aceite
  * Revisión de neumáticos
  * Revisión de frenos
  * Revisión general
- Mantenimiento correctivo
  * Reparación de averías
  * Sustitución de piezas
  * Reparaciones de emergencia
- Costes de mantenimiento
  * Piezas de recambio
  * Mano de obra
  * Tiempo de inactividad

#### Mejoras y Personalización
- Motor
  * Aumento de potencia
  * Reducción de consumo
  * Mejora de fiabilidad
- Chasis
  * Mejora de suspensión
  * Refuerzo estructural
  * Mejora de aerodinámica
- Cabina
  * Comodidad del conductor
  * Sistemas de navegación
  * Sistemas de seguridad
- Carga
  * Sistemas de carga/descarga
  * Equipamiento especializado
  * Sistemas de control de temperatura

### Restricciones y Regulaciones

#### Permisos y Licencias
- Permisos por tipo de vehículo
- Permisos por tipo de carga
- Permisos internacionales
- Certificaciones especiales
- Costes y renovaciones

#### Restricciones de Circulación
- Zonas de bajas emisiones
- Restricciones por peso
- Restricciones por dimensiones
- Restricciones horarias
- Rutas alternativas

#### Normativa de Carga
- Peso máximo por eje
- Dimensiones máximas
- Carga peligrosa
- Carga perecedera
- Documentación requerida

## Modos de Juego

### Modo Carrera
- Progresión gradual de dificultad
- Objetivos específicos por nivel
- Sistema de reputación y clientes
- Desbloqueo de nuevas rutas y vehículos
- Misiones principales
- Misiones secundarias
- Eventos especiales
- Logros y recompensas

### Modo Libre
- Acceso a todos los vehículos y rutas
- Sin restricciones de tiempo
- Enfoque en la experimentación y optimización
- Personalización completa
- Modo sandbox
- Herramientas de prueba
- Escenarios personalizados

### Modo Desafío
- Escenarios con condiciones específicas
- Objetivos a tiempo limitado
- Condiciones climáticas adversas
- Restricciones de recursos
- Desafíos diarios
- Desafíos semanales
- Competencias globales
- Rankings y premios

## Dificultades

### Principiante
- Tutorial completo
- Asistencia en la gestión
- Menos restricciones
- Mayor margen de error
- Ayudas visuales
- Consejos en tiempo real
- Sistema de guardado automático
- Modo práctica

### Intermedio
- Gestión más compleja
- Restricciones realistas
- Sistema de mantenimiento más detallado
- Competencia más agresiva
- Menos ayudas
- Mayor responsabilidad
- Eventos aleatorios moderados
- Economía más realista

### Experto
- Gestión completa de todos los aspectos
- Condiciones climáticas realistas
- Competencia feroz
- Eventos aleatorios y crisis
- Sin ayudas
- Máxima dificultad
- Economía volátil
- Eventos extremos

## Características Adicionales

### Sistema Económico
- Gestión de finanzas
  * Ingresos por entregas
  * Costes operativos
  * Impuestos y tasas
  * Beneficios netos
- Inversiones en infraestructura
  * Centros logísticos
  * Talleres
  * Almacenes
  * Oficinas
- Sistema de préstamos y créditos
  * Préstamos bancarios
  * Líneas de crédito
  * Inversores
  * Subvenciones
- Fluctuaciones del mercado
  * Estacionalidad
  * Crisis económicas
  * Oportunidades de mercado
  * Competencia

### Personal
- Contratación de conductores
  * Experiencia
  * Especializaciones
  * Salarios
  * Beneficios
- Formación y especialización
  * Cursos de conducción
  * Certificaciones
  * Habilidades especiales
  * Desarrollo profesional
- Gestión de turnos
  * Planificación
  * Descansos
  * Horas extra
  * Rotaciones
- Sistema de incentivos
  * Bonificaciones
  * Premios
  * Promociones
  * Beneficios sociales

### Infraestructura
- Construcción de centros logísticos
  * Ubicación
  * Capacidad
  * Especialización
  * Costes
- Mejora de rutas
  * Pavimentación
  * Señalización
  * Seguridad
  * Eficiencia
- Inversión en tecnología
  * Sistemas de gestión
  * Automatización
  * Seguridad
  * Comunicaciones
- Gestión de almacenes
  * Capacidad
  * Organización
  * Seguridad
  * Eficiencia

### Eventos Dinámicos
- Condiciones climáticas
  * Lluvia
  * Nieve
  * Niebla
  * Viento
- Huelgas y protestas
  * Sindicatos
  * Bloqueos
  * Negociaciones
  * Resolución
- Cambios en la normativa
  * Nuevas leyes
  * Restricciones
  * Oportunidades
  * Adaptación
- Oportunidades de negocio
  * Contratos especiales
  * Nuevas rutas
  * Alianzas
  * Expansión

## Sistema de Progresión

### Niveles de Empresa
- Empresa local
- Empresa regional
- Empresa nacional
- Empresa internacional
- Corporación global

### Reputación
- Calificación por cliente
- Calificación por región
- Calificación global
- Efectos en el negocio
- Beneficios de alta reputación

### Logros
- Logros por categoría
- Logros especiales
- Recompensas
- Desbloqueos
- Títulos y reconocimientos

## Arquitectura y Patrones de Diseño

### Arquitectura General
El proyecto está estructurado siguiendo una arquitectura modular y escalable, utilizando principalmente el patrón Modelo-Vista-Controlador (MVC) para separar las responsabilidades y mantener el código organizado y mantenible.

#### Capas Principales
- **Capa de Presentación (Vista)**
  * Interfaz de usuario
  * Menús y HUD
  * Sistema de notificaciones
  * Visualización de datos

- **Capa de Lógica (Controlador)**
  * Gestión de la lógica de negocio
  * Control de flujo del juego
  * Manejo de eventos
  * Coordinación entre sistemas

- **Capa de Datos (Modelo)**
  * Estructuras de datos
  * Persistencia
  * Estado del juego
  * Configuraciones

### Patrones de Diseño Implementados

#### Patrones Creacionales
- **Factory Method**
  * Creación de vehículos
  * Generación de misiones
  * Creación de eventos
  * Instanciación de UI

- **Singleton**
  * Gestor de recursos
  * Sistema de audio
  * Gestor de eventos
  * Sistema de guardado

- **Builder**
  * Construcción de vehículos
  * Creación de rutas
  * Generación de misiones
  * Configuración de empresas

#### Patrones Estructurales
- **Composite**
  * Sistema de misiones
  * Jerarquía de vehículos
  * Estructura de la empresa
  * Sistema de logros

- **Adapter**
  * Integración con APIs externas
  * Compatibilidad entre sistemas
  * Conversión de formatos
  * Adaptación de interfaces

- **Decorator**
  * Mejoras de vehículos
  * Modificadores de misiones
  * Efectos de clima
  * Bonificaciones temporales

#### Patrones de Comportamiento
- **Observer**
  * Sistema de eventos
  * Notificaciones
  * Actualizaciones de UI
  * Sistema de logros

- **Strategy**
  * Algoritmos de ruta
  * Sistemas de precios
  * Métodos de mantenimiento
  * Tácticas de competencia

- **Command**
  * Sistema de acciones
  * Deshacer/Rehacer
  * Macros
  * Automatización

### Estructura del Código

#### Organización de Directorios
```
src/
├── core/           # Núcleo del juego
├── entities/       # Entidades principales
├── systems/        # Sistemas de juego
├── ui/            # Interfaz de usuario
├── utils/         # Utilidades
└── data/          # Datos y configuraciones
```

#### Componentes Principales
- **Core**
  * Motor del juego
  * Sistema de eventos
  * Gestión de recursos
  * Loop principal

- **Entities**
  * Vehículos
  * Conductores
  * Empresas
  * Misiones

- **Systems**
  * Sistema económico
  * Sistema de física
  * Sistema de IA
  * Sistema de guardado

### Optimizaciones

#### Rendimiento
- Pooling de objetos
- Culling de entidades
- Lazy loading
- Optimización de memoria

#### Mantenibilidad
- Documentación extensa
- Tests unitarios
- Code review
- Estándares de código

#### Escalabilidad
- Arquitectura modular
- Sistema de plugins
- APIs extensibles
- Configuración dinámica

### Tecnologías Utilizadas

#### Frontend
- Unity como motor principal
- C# como lenguaje de programación
- Shader Graph para efectos visuales
- UI Toolkit para interfaces

#### Backend
- Sistema de guardado local
- Base de datos SQLite
- Sistema de logs
- Profiling tools

#### Herramientas de Desarrollo
- Git para control de versiones
- CI/CD con GitHub Actions
- Jira para gestión de tareas
- Confluence para documentación

### Patrón Template Method en Skyline Logistics

#### Descripción General
El patrón Template Method se ha implementado como una solución fundamental para estandarizar procesos y comportamientos comunes en diferentes partes del juego, permitiendo la personalización de pasos específicos mientras se mantiene una estructura base consistente.

#### Implementación Principal

##### Clase Base Abstracta
```csharp
public abstract class GameProcessTemplate
{
    // Método template que define el esqueleto del algoritmo
    public final void ExecuteProcess()
    {
        Initialize();
        LoadResources();
        ProcessLogic();
        SaveState();
        Cleanup();
    }

    // Métodos que deben ser implementados por las subclases
    protected abstract void Initialize();
    protected abstract void ProcessLogic();
    protected abstract void SaveState();

    // Métodos con implementación por defecto
    protected virtual void LoadResources()
    {
        // Implementación base
    }

    protected virtual void Cleanup()
    {
        // Implementación base
    }
}
```

#### Casos de Uso

##### 1. Sistema de Misiones
- **Propósito**: Estandarizar el flujo de ejecución de misiones
- **Implementación**:
  * `MissionTemplate`: Clase base abstracta
  * `DeliveryMission`: Implementación específica para entregas
  * `CollectionMission`: Implementación específica para recolecciones
  * `SpecialMission`: Implementación para misiones especiales

##### 2. Sistema de Mantenimiento
- **Propósito**: Unificar el proceso de mantenimiento de vehículos
- **Implementación**:
  * `MaintenanceTemplate`: Clase base abstracta
  * `PreventiveMaintenance`: Mantenimiento preventivo
  * `CorrectiveMaintenance`: Mantenimiento correctivo
  * `EmergencyMaintenance`: Mantenimiento de emergencia

##### 3. Sistema de Carga/Descarga
- **Propósito**: Estandarizar el proceso de manipulación de mercancías
- **Implementación**:
  * `CargoOperationTemplate`: Clase base abstracta
  * `LoadingOperation`: Operaciones de carga
  * `UnloadingOperation`: Operaciones de descarga
  * `TransferOperation`: Operaciones de transferencia

#### Ventajas de la Implementación

##### 1. Reutilización de Código
- Eliminación de código duplicado
- Centralización de la lógica común
- Mantenimiento simplificado
- Consistencia en la implementación

##### 2. Flexibilidad
- Personalización de pasos específicos
- Extensibilidad del sistema
- Adaptabilidad a nuevos requisitos
- Fácil integración de nuevas funcionalidades

##### 3. Control de Flujo
- Estructura predecible
- Manejo consistente de errores
- Puntos de extensión claros
- Validación centralizada

#### Ejemplos Específicos

##### Sistema de Misiones
```csharp
public abstract class MissionTemplate
{
    public final void ExecuteMission()
    {
        ValidateRequirements();
        AssignResources();
        ExecuteDelivery();
        UpdateProgress();
        CompleteMission();
    }

    protected abstract void ValidateRequirements();
    protected abstract void ExecuteDelivery();
    protected abstract void CompleteMission();

    protected virtual void AssignResources()
    {
        // Implementación base
    }

    protected virtual void UpdateProgress()
    {
        // Implementación base
    }
}
```

##### Sistema de Mantenimiento
```csharp
public abstract class MaintenanceTemplate
{
    public final void PerformMaintenance()
    {
        CheckVehicleStatus();
        PrepareTools();
        ExecuteMaintenance();
        TestVehicle();
        UpdateRecords();
    }

    protected abstract void ExecuteMaintenance();
    protected abstract void TestVehicle();

    protected virtual void CheckVehicleStatus()
    {
        // Implementación base
    }

    protected virtual void PrepareTools()
    {
        // Implementación base
    }

    protected virtual void UpdateRecords()
    {
        // Implementación base
    }
}
```

#### Beneficios en el Proyecto

##### 1. Mantenibilidad
- Código más organizado
- Menor complejidad
- Mejor documentación
- Facilidad de debugging

##### 2. Escalabilidad
- Fácil adición de nuevos tipos
- Extensión de funcionalidades
- Adaptación a cambios
- Soporte para nuevas características

##### 3. Calidad
- Menos errores
- Mejor testing
- Mayor robustez
- Mejor rendimiento

#### Consideraciones de Diseño

##### 1. Abstracción
- Nivel adecuado de generalización
- Balance entre flexibilidad y estructura
- Claridad en la interfaz
- Documentación clara

##### 2. Extensibilidad
- Puntos de extensión bien definidos
- Hooks para personalización
- Manejo de casos especiales
- Soporte para futuras mejoras

##### 3. Rendimiento
- Optimización de métodos comunes
- Caching cuando es posible
- Minimización de overhead
- Profiling y optimización

### Patrón Strategy en Skyline Logistics

#### Descripción General
El patrón Strategy se ha implementado para encapsular diferentes algoritmos y comportamientos, permitiendo que estos sean intercambiables en tiempo de ejecución. Este patrón es fundamental para manejar la variabilidad en los comportamientos del juego, especialmente en sistemas que requieren diferentes enfoques según el contexto.

#### Implementación Principal

##### Interfaz de Estrategia
```csharp
public interface IStrategy
{
    void Execute();
    bool CanExecute();
    float GetCost();
}
```

##### Contexto
```csharp
public class StrategyContext
{
    private IStrategy _strategy;

    public void SetStrategy(IStrategy strategy)
    {
        _strategy = strategy;
    }

    public void ExecuteStrategy()
    {
        if (_strategy.CanExecute())
        {
            _strategy.Execute();
        }
    }

    public float GetStrategyCost()
    {
        return _strategy.GetCost();
    }
}
```

#### Casos de Uso

##### 1. Sistema de Rutas
- **Propósito**: Implementar diferentes algoritmos de cálculo de rutas
- **Implementación**:
  * `IRouteStrategy`: Interfaz base
  * `ShortestPathStrategy`: Ruta más corta
  * `FuelEfficientStrategy`: Ruta más eficiente en combustible
  * `TimeOptimizedStrategy`: Ruta más rápida
  * `ScenicRouteStrategy`: Ruta con mejor paisaje

##### 2. Sistema de Precios
- **Propósito**: Implementar diferentes estrategias de precios
- **Implementación**:
  * `IPricingStrategy`: Interfaz base
  * `StandardPricingStrategy`: Precios estándar
  * `DynamicPricingStrategy`: Precios dinámicos
  * `BulkPricingStrategy`: Precios por volumen
  * `PremiumPricingStrategy`: Precios premium

##### 3. Sistema de Mantenimiento
- **Propósito**: Implementar diferentes estrategias de mantenimiento
- **Implementación**:
  * `IMaintenanceStrategy`: Interfaz base
  * `PreventiveMaintenanceStrategy`: Mantenimiento preventivo
  * `PredictiveMaintenanceStrategy`: Mantenimiento predictivo
  * `ReactiveMaintenanceStrategy`: Mantenimiento reactivo

#### Ejemplos Específicos

##### Sistema de Rutas
```csharp
public interface IRouteStrategy
{
    Route CalculateRoute(Location start, Location end, Vehicle vehicle);
    float EstimateTime(Route route);
    float EstimateCost(Route route);
}

public class ShortestPathStrategy : IRouteStrategy
{
    public Route CalculateRoute(Location start, Location end, Vehicle vehicle)
    {
        // Implementación del algoritmo de ruta más corta
    }

    public float EstimateTime(Route route)
    {
        // Cálculo del tiempo estimado
    }

    public float EstimateCost(Route route)
    {
        // Cálculo del coste estimado
    }
}

public class FuelEfficientStrategy : IRouteStrategy
{
    public Route CalculateRoute(Location start, Location end, Vehicle vehicle)
    {
        // Implementación del algoritmo de eficiencia de combustible
    }

    public float EstimateTime(Route route)
    {
        // Cálculo del tiempo estimado
    }

    public float EstimateCost(Route route)
    {
        // Cálculo del coste estimado
    }
}
```

##### Sistema de Precios
```csharp
public interface IPricingStrategy
{
    float CalculatePrice(Delivery delivery);
    float CalculateDiscount(Delivery delivery);
    float CalculateAdditionalCharges(Delivery delivery);
}

public class DynamicPricingStrategy : IPricingStrategy
{
    public float CalculatePrice(Delivery delivery)
    {
        // Cálculo de precio basado en demanda
    }

    public float CalculateDiscount(Delivery delivery)
    {
        // Cálculo de descuentos dinámicos
    }

    public float CalculateAdditionalCharges(Delivery delivery)
    {
        // Cálculo de cargos adicionales
    }
}
```

#### Ventajas de la Implementación

##### 1. Flexibilidad
- Cambio dinámico de estrategias
- Fácil adición de nuevas estrategias
- Adaptabilidad a diferentes situaciones
- Personalización de comportamientos

##### 2. Mantenibilidad
- Separación de responsabilidades
- Código más organizado
- Facilidad de testing
- Mejor documentación

##### 3. Extensibilidad
- Nuevas estrategias sin modificar código existente
- Fácil integración de nuevas funcionalidades
- Soporte para futuras mejoras
- Adaptación a nuevos requisitos

#### Beneficios en el Proyecto

##### 1. Toma de Decisiones
- Algoritmos optimizados
- Mejor rendimiento
- Mayor precisión
- Adaptabilidad

##### 2. Experiencia de Usuario
- Comportamientos más realistas
- Mayor variedad de opciones
- Mejor personalización
- Mayor inmersión

##### 3. Desarrollo
- Código más limpio
- Mejor organización
- Facilidad de mantenimiento
- Mejor testing

#### Consideraciones de Diseño

##### 1. Selección de Estrategia
- Criterios de selección
- Cambio de estrategia
- Validación de estrategias
- Fallback strategies

##### 2. Rendimiento
- Caching de resultados
- Optimización de algoritmos
- Minimización de overhead
- Profiling y optimización

##### 3. Integración
- Compatibilidad con otros patrones
- Manejo de dependencias
- Inyección de dependencias
- Testing y validación

### Patrón State en Skyline Logistics

#### Descripción General
El patrón State se ha implementado para manejar los diferentes estados en los que pueden encontrarse las entidades del juego, permitiendo que su comportamiento cambie según el estado actual. Este patrón es fundamental para gestionar las transiciones de estado de manera limpia y mantenible, especialmente en sistemas complejos como vehículos, misiones y empresas.

#### Implementación Principal

##### Interfaz de Estado
```csharp
public interface IState
{
    void Enter();
    void Update();
    void Exit();
    bool CanTransitionTo(IState nextState);
}
```

##### Contexto
```csharp
public class StateContext
{
    private IState _currentState;
    private Dictionary<Type, IState> _states;

    public StateContext()
    {
        _states = new Dictionary<Type, IState>();
    }

    public void RegisterState(IState state)
    {
        _states[state.GetType()] = state;
    }

    public void TransitionTo<T>() where T : IState
    {
        var nextState = _states[typeof(T)];
        if (_currentState?.CanTransitionTo(nextState) ?? true)
        {
            _currentState?.Exit();
            _currentState = nextState;
            _currentState.Enter();
        }
    }

    public void Update()
    {
        _currentState?.Update();
    }
}
```

#### Casos de Uso

##### 1. Estados de Vehículos
- **Propósito**: Gestionar los diferentes estados de los vehículos
- **Implementación**:
  * `IVehicleState`: Interfaz base
  * `IdleState`: Vehículo en espera
  * `MovingState`: Vehículo en movimiento
  * `LoadingState`: Vehículo cargando
  * `UnloadingState`: Vehículo descargando
  * `MaintenanceState`: Vehículo en mantenimiento
  * `BrokenState`: Vehículo averiado

##### 2. Estados de Misiones
- **Propósito**: Gestionar el ciclo de vida de las misiones
- **Implementación**:
  * `IMissionState`: Interfaz base
  * `AvailableState`: Misión disponible
  * `AssignedState`: Misión asignada
  * `InProgressState`: Misión en progreso
  * `CompletedState`: Misión completada
  * `FailedState`: Misión fallida
  * `CancelledState`: Misión cancelada

##### 3. Estados de Empresa
- **Propósito**: Gestionar los diferentes estados de la empresa
- **Implementación**:
  * `ICompanyState`: Interfaz base
  * `StartupState`: Empresa en inicio
  * `GrowingState`: Empresa en crecimiento
  * `StableState`: Empresa estable
  * `ExpandingState`: Empresa en expansión
  * `CrisisState`: Empresa en crisis

#### Ejemplos Específicos

##### Estados de Vehículos
```csharp
public interface IVehicleState : IState
{
    void HandleInput(VehicleInput input);
    void UpdateVehicleStats(VehicleStats stats);
}

public class MovingState : IVehicleState
{
    private readonly Vehicle _vehicle;

    public MovingState(Vehicle vehicle)
    {
        _vehicle = vehicle;
    }

    public void Enter()
    {
        _vehicle.StartEngine();
        _vehicle.EnablePhysics();
    }

    public void Update()
    {
        _vehicle.UpdatePosition();
        _vehicle.UpdateFuel();
        _vehicle.UpdateWear();
    }

    public void Exit()
    {
        _vehicle.DisablePhysics();
    }

    public bool CanTransitionTo(IState nextState)
    {
        return nextState is IdleState || 
               nextState is LoadingState || 
               nextState is MaintenanceState;
    }

    public void HandleInput(VehicleInput input)
    {
        // Manejo de input específico para estado en movimiento
    }

    public void UpdateVehicleStats(VehicleStats stats)
    {
        // Actualización de estadísticas específicas
    }
}
```

##### Estados de Misiones
```csharp
public interface IMissionState : IState
{
    void HandleProgress(float progress);
    void HandleFailure(string reason);
    void HandleCompletion();
}

public class InProgressState : IMissionState
{
    private readonly Mission _mission;

    public InProgressState(Mission mission)
    {
        _mission = mission;
    }

    public void Enter()
    {
        _mission.StartTimer();
        _mission.NotifyStart();
    }

    public void Update()
    {
        _mission.UpdateProgress();
        _mission.CheckTimeLimit();
        _mission.UpdateRewards();
    }

    public void Exit()
    {
        _mission.StopTimer();
    }

    public bool CanTransitionTo(IState nextState)
    {
        return nextState is CompletedState || 
               nextState is FailedState || 
               nextState is CancelledState;
    }

    public void HandleProgress(float progress)
    {
        _mission.UpdateProgress(progress);
    }

    public void HandleFailure(string reason)
    {
        _mission.SetFailureReason(reason);
    }

    public void HandleCompletion()
    {
        _mission.CalculateFinalRewards();
    }
}
```

#### Ventajas de la Implementación

##### 1. Organización
- Estados claramente definidos
- Transiciones controladas
- Comportamiento encapsulado
- Mejor mantenibilidad

##### 2. Flexibilidad
- Fácil adición de nuevos estados
- Modificación de comportamientos
- Adaptabilidad a cambios
- Personalización de estados

##### 3. Robustez
- Validación de transiciones
- Manejo de errores
- Estados consistentes
- Comportamiento predecible

#### Beneficios en el Proyecto

##### 1. Gestión de Estados
- Control preciso de estados
- Transiciones suaves
- Comportamiento consistente
- Mejor debugging

##### 2. Experiencia de Usuario
- Comportamientos realistas
- Feedback claro
- Transiciones fluidas
- Mayor inmersión

##### 3. Desarrollo
- Código más organizado
- Mejor testing
- Facilidad de mantenimiento
- Mejor documentación

#### Consideraciones de Diseño

##### 1. Transiciones
- Validación de transiciones
- Manejo de casos especiales
- Transiciones forzadas
- Estados temporales

##### 2. Rendimiento
- Optimización de estados
- Caching de estados
- Minimización de overhead
- Profiling y optimización

##### 3. Integración
- Compatibilidad con otros patrones
- Manejo de dependencias
- Inyección de dependencias
- Testing y validación

### Patrón Singleton en Skyline Logistics

#### Descripción General
El patrón Singleton se ha implementado para garantizar que ciertos servicios y gestores críticos del juego tengan una única instancia global, asegurando un acceso centralizado y controlado a recursos compartidos. Este patrón es fundamental para gestionar servicios que deben ser accesibles desde cualquier parte del juego y que requieren un estado global consistente.

#### Implementación Principal

##### Singleton Base
```csharp
public abstract class Singleton<T> where T : class, new()
{
    private static T _instance;
    private static readonly object _lock = new object();
    private static bool _isInitialized;

    public static T Instance
    {
        get
        {
            if (!_isInitialized)
            {
                lock (_lock)
                {
                    if (!_isInitialized)
                    {
                        _instance = new T();
                        _isInitialized = true;
                    }
                }
            }
            return _instance;
        }
    }

    protected Singleton()
    {
        if (_isInitialized)
        {
            throw new Exception($"Ya existe una instancia de {typeof(T).Name}");
        }
    }
}
```

#### Casos de Uso

##### 1. Gestores de Sistema
- **Propósito**: Gestionar servicios globales del juego
- **Implementación**:
  * `GameManager`: Gestión general del juego
  * `ResourceManager`: Gestión de recursos
  * `AudioManager`: Sistema de audio
  * `InputManager`: Control de entrada
  * `SaveManager`: Sistema de guardado
  * `EventManager`: Sistema de eventos

##### 2. Servicios de Negocio
- **Propósito**: Gestionar lógica de negocio global
- **Implementación**:
  * `EconomyManager`: Sistema económico
  * `MissionManager`: Gestión de misiones
  * `VehicleManager`: Gestión de vehículos
  * `CompanyManager`: Gestión de empresa
  * `ReputationManager`: Sistema de reputación

##### 3. Servicios Técnicos
- **Propósito**: Gestionar servicios técnicos
- **Implementación**:
  * `NetworkManager`: Gestión de red
  * `DatabaseManager`: Acceso a base de datos
  * `AnalyticsManager`: Sistema de análisis
  * `LogManager`: Sistema de logs
  * `ConfigManager`: Gestión de configuración

#### Ejemplos Específicos

##### GameManager
```csharp
public class GameManager : Singleton<GameManager>
{
    private GameState _currentState;
    private bool _isPaused;
    private float _gameTime;

    public void Initialize()
    {
        _currentState = GameState.MainMenu;
        _isPaused = false;
        _gameTime = 0f;
    }

    public void Update()
    {
        if (!_isPaused)
        {
            _gameTime += Time.deltaTime;
            UpdateGameState();
        }
    }

    public void PauseGame()
    {
        _isPaused = true;
        Time.timeScale = 0f;
    }

    public void ResumeGame()
    {
        _isPaused = false;
        Time.timeScale = 1f;
    }

    private void UpdateGameState()
    {
        // Lógica de actualización del estado del juego
    }
}
```

##### ResourceManager
```csharp
public class ResourceManager : Singleton<ResourceManager>
{
    private Dictionary<string, UnityEngine.Object> _cachedResources;
    private Dictionary<string, int> _referenceCounts;

    public T LoadResource<T>(string path) where T : UnityEngine.Object
    {
        if (_cachedResources.ContainsKey(path))
        {
            _referenceCounts[path]++;
            return _cachedResources[path] as T;
        }

        var resource = Resources.Load<T>(path);
        if (resource != null)
        {
            _cachedResources[path] = resource;
            _referenceCounts[path] = 1;
        }
        return resource;
    }

    public void UnloadResource(string path)
    {
        if (_cachedResources.ContainsKey(path))
        {
            _referenceCounts[path]--;
            if (_referenceCounts[path] <= 0)
            {
                Resources.UnloadAsset(_cachedResources[path]);
                _cachedResources.Remove(path);
                _referenceCounts.Remove(path);
            }
        }
    }
}
```

#### Ventajas de la Implementación

##### 1. Control de Acceso
- Punto único de acceso
- Estado global consistente
- Control de inicialización
- Gestión de recursos

##### 2. Eficiencia
- Reutilización de instancias
- Optimización de memoria
- Caching de recursos
- Mejor rendimiento

##### 3. Mantenibilidad
- Código más organizado
- Mejor testing
- Facilidad de debugging
- Mejor documentación

#### Beneficios en el Proyecto

##### 1. Gestión de Recursos
- Control centralizado
- Mejor optimización
- Menor uso de memoria
- Carga eficiente

##### 2. Estado Global
- Consistencia de datos
- Sincronización
- Persistencia
- Control de flujo

##### 3. Desarrollo
- Código más limpio
- Mejor organización
- Facilidad de mantenimiento
- Mejor testing

#### Consideraciones de Diseño

##### 1. Inicialización
- Lazy initialization
- Thread safety
- Orden de inicialización
- Manejo de errores

##### 2. Rendimiento
- Optimización de memoria
- Caching
- Minimización de overhead
- Profiling

##### 3. Testing
- Mocking de singletons
- Testing unitario
- Testing de integración
- Testing de rendimiento

#### Mejores Prácticas

##### 1. Uso Responsable
- Solo para servicios globales
- Evitar abuso del patrón
- Considerar alternativas
- Documentar decisiones

##### 2. Thread Safety
- Sincronización
- Manejo de concurrencia
- Prevención de deadlocks
- Optimización de locks

##### 3. Mantenimiento
- Documentación clara
- Código limpio
- Testing exhaustivo
- Revisión periódica

### Patrón Abstract Factory en Skyline Logistics

#### Descripción General
El patrón Abstract Factory se ha implementado para proporcionar una interfaz que permita crear familias de objetos relacionados sin especificar sus clases concretas. Este patrón es fundamental para mantener la flexibilidad y extensibilidad del sistema, especialmente en la creación de vehículos, misiones y otros elementos del juego que tienen variantes específicas.

#### Implementación Principal

##### Fábrica Abstracta Base
```csharp
public interface IVehicleFactory
{
    IVehicle CreateVehicle(VehicleType type);
    IEngine CreateEngine(EngineType type);
    IChassis CreateChassis(ChassisType type);
    ICabin CreateCabin(CabinType type);
}

public interface IMissionFactory
{
    IMission CreateMission(MissionType type);
    IReward CreateReward(RewardType type);
    IObjective CreateObjective(ObjectiveType type);
    ITimeLimit CreateTimeLimit(TimeLimitType type);
}
```

#### Casos de Uso

##### 1. Sistema de Vehículos
- **Propósito**: Crear familias de vehículos y sus componentes
- **Implementación**:
  * `IVehicleFactory`: Fábrica base
  * `UrbanVehicleFactory`: Vehículos urbanos
  * `HighwayVehicleFactory`: Vehículos de carretera
  * `SpecializedVehicleFactory`: Vehículos especializados
  * `PremiumVehicleFactory`: Vehículos premium

##### 2. Sistema de Misiones
- **Propósito**: Crear familias de misiones y sus componentes
- **Implementación**:
  * `IMissionFactory`: Fábrica base
  * `DeliveryMissionFactory`: Misiones de entrega
  * `CollectionMissionFactory`: Misiones de recolección
  * `SpecialMissionFactory`: Misiones especiales
  * `TimeTrialMissionFactory`: Misiones contra reloj

##### 3. Sistema de UI
- **Propósito**: Crear familias de elementos de interfaz
- **Implementación**:
  * `IUIFactory`: Fábrica base
  * `MainMenuUIFactory`: UI del menú principal
  * `GameplayUIFactory`: UI durante el juego
  * `MissionUIFactory`: UI de misiones
  * `VehicleUIFactory`: UI de vehículos

#### Ejemplos Específicos

##### Fábrica de Vehículos
```csharp
public class UrbanVehicleFactory : IVehicleFactory
{
    public IVehicle CreateVehicle(VehicleType type)
    {
        switch (type)
        {
            case VehicleType.Van:
                return new UrbanVan();
            case VehicleType.SmallTruck:
                return new UrbanSmallTruck();
            case VehicleType.DeliveryVan:
                return new UrbanDeliveryVan();
            default:
                throw new ArgumentException($"Tipo de vehículo no soportado: {type}");
        }
    }

    public IEngine CreateEngine(EngineType type)
    {
        switch (type)
        {
            case EngineType.Electric:
                return new UrbanElectricEngine();
            case EngineType.Hybrid:
                return new UrbanHybridEngine();
            case EngineType.Combustion:
                return new UrbanCombustionEngine();
            default:
                throw new ArgumentException($"Tipo de motor no soportado: {type}");
        }
    }

    public IChassis CreateChassis(ChassisType type)
    {
        switch (type)
        {
            case ChassisType.Light:
                return new UrbanLightChassis();
            case ChassisType.Medium:
                return new UrbanMediumChassis();
            default:
                throw new ArgumentException($"Tipo de chasis no soportado: {type}");
        }
    }

    public ICabin CreateCabin(CabinType type)
    {
        switch (type)
        {
            case CabinType.Basic:
                return new UrbanBasicCabin();
            case CabinType.Comfort:
                return new UrbanComfortCabin();
            default:
                throw new ArgumentException($"Tipo de cabina no soportado: {type}");
        }
    }
}
```

##### Fábrica de Misiones
```csharp
public class DeliveryMissionFactory : IMissionFactory
{
    public IMission CreateMission(MissionType type)
    {
        switch (type)
        {
            case MissionType.Standard:
                return new StandardDeliveryMission();
            case MissionType.Express:
                return new ExpressDeliveryMission();
            case MissionType.Bulk:
                return new BulkDeliveryMission();
            default:
                throw new ArgumentException($"Tipo de misión no soportado: {type}");
        }
    }

    public IReward CreateReward(RewardType type)
    {
        switch (type)
        {
            case RewardType.Money:
                return new MoneyReward();
            case RewardType.Reputation:
                return new ReputationReward();
            case RewardType.Experience:
                return new ExperienceReward();
            default:
                throw new ArgumentException($"Tipo de recompensa no soportado: {type}");
        }
    }

    public IObjective CreateObjective(ObjectiveType type)
    {
        switch (type)
        {
            case ObjectiveType.Delivery:
                return new DeliveryObjective();
            case ObjectiveType.Time:
                return new TimeObjective();
            case ObjectiveType.Distance:
                return new DistanceObjective();
            default:
                throw new ArgumentException($"Tipo de objetivo no soportado: {type}");
        }
    }

    public ITimeLimit CreateTimeLimit(TimeLimitType type)
    {
        switch (type)
        {
            case TimeLimitType.Strict:
                return new StrictTimeLimit();
            case TimeLimitType.Flexible:
                return new FlexibleTimeLimit();
            default:
                throw new ArgumentException($"Tipo de límite de tiempo no soportado: {type}");
        }
    }
}
```

#### Ventajas de la Implementación

##### 1. Flexibilidad
- Creación de familias de objetos
- Fácil extensión
- Adaptabilidad a cambios
- Personalización de componentes

##### 2. Encapsulación
- Ocultación de implementaciones
- Separación de responsabilidades
- Mejor organización
- Código más limpio

##### 3. Mantenibilidad
- Fácil adición de nuevos tipos
- Mejor testing
- Mejor documentación
- Facilidad de debugging

#### Beneficios en el Proyecto

##### 1. Creación de Objetos
- Proceso estandarizado
- Consistencia en la creación
- Validación centralizada
- Mejor control

##### 2. Extensibilidad
- Nuevos tipos de objetos
- Nuevas variantes
- Adaptación a requisitos
- Soporte para DLC

##### 3. Desarrollo
- Código más organizado
- Mejor testing
- Facilidad de mantenimiento
- Mejor documentación

#### Consideraciones de Diseño

##### 1. Diseño de Fábricas
- Nivel de abstracción
- Granularidad
- Reutilización
- Extensibilidad

##### 2. Rendimiento
- Caching de objetos
- Pooling
- Optimización
- Profiling

##### 3. Testing
- Mocking de fábricas
- Testing unitario
- Testing de integración
- Testing de rendimiento

#### Mejores Prácticas

##### 1. Diseño de Interfaces
- Interfaces claras
- Documentación
- Validación
- Manejo de errores

##### 2. Implementación
- Código limpio
- Patrones de diseño
- Optimización
- Testing

##### 3. Mantenimiento
- Documentación
- Revisión de código
- Actualización
- Mejora continua

### Patrón Facade en Skyline Logistics

#### Descripción General
El patrón Facade se ha implementado para proporcionar una interfaz simplificada a subsistemas complejos del juego, ocultando la complejidad de las interacciones entre diferentes componentes. Este patrón es fundamental para mejorar la usabilidad y mantenibilidad del código, especialmente en sistemas que requieren la coordinación de múltiples subsistemas.

#### Implementación Principal

##### Fachada Principal
```csharp
public class GameFacade
{
    private readonly VehicleManager _vehicleManager;
    private readonly MissionManager _missionManager;
    private readonly EconomyManager _economyManager;
    private readonly CompanyManager _companyManager;
    private readonly EventManager _eventManager;

    public GameFacade()
    {
        _vehicleManager = new VehicleManager();
        _missionManager = new MissionManager();
        _economyManager = new EconomyManager();
        _companyManager = new CompanyManager();
        _eventManager = new EventManager();
    }

    public void InitializeGame()
    {
        _companyManager.Initialize();
        _vehicleManager.Initialize();
        _missionManager.Initialize();
        _economyManager.Initialize();
        _eventManager.Initialize();
    }

    public void StartMission(MissionData missionData)
    {
        var vehicle = _vehicleManager.GetAvailableVehicle(missionData.RequiredVehicleType);
        var mission = _missionManager.CreateMission(missionData);
        var cost = _economyManager.CalculateMissionCost(mission);
        
        if (_companyManager.CanAfford(cost))
        {
            _companyManager.DeductFunds(cost);
            _missionManager.AssignMission(mission, vehicle);
            _eventManager.NotifyMissionStarted(mission);
        }
    }

    public void CompleteMission(Mission mission)
    {
        var reward = _missionManager.CalculateReward(mission);
        _companyManager.AddFunds(reward.Money);
        _companyManager.AddReputation(reward.Reputation);
        _vehicleManager.UpdateVehicleStatus(mission.Vehicle);
        _eventManager.NotifyMissionCompleted(mission);
    }
}
```

#### Casos de Uso

##### 1. Sistema de Misiones
- **Propósito**: Simplificar la interacción con el sistema de misiones
- **Implementación**:
  * `MissionFacade`: Coordinación de misiones
  * `DeliveryFacade`: Gestión de entregas
  * `CollectionFacade`: Gestión de recolecciones
  * `SpecialMissionFacade`: Gestión de misiones especiales

##### 2. Sistema de Vehículos
- **Propósito**: Simplificar la gestión de vehículos
- **Implementación**:
  * `VehicleFacade`: Gestión general de vehículos
  * `MaintenanceFacade`: Gestión de mantenimiento
  * `FleetFacade`: Gestión de flota
  * `UpgradeFacade`: Gestión de mejoras

##### 3. Sistema de Empresa
- **Propósito**: Simplificar la gestión empresarial
- **Implementación**:
  * `CompanyFacade`: Gestión general de empresa
  * `FinanceFacade`: Gestión financiera
  * `PersonnelFacade`: Gestión de personal
  * `InfrastructureFacade`: Gestión de infraestructura

#### Ejemplos Específicos

##### MissionFacade
```csharp
public class MissionFacade
{
    private readonly MissionManager _missionManager;
    private readonly VehicleManager _vehicleManager;
    private readonly EconomyManager _economyManager;
    private readonly EventManager _eventManager;

    public MissionFacade(
        MissionManager missionManager,
        VehicleManager vehicleManager,
        EconomyManager economyManager,
        EventManager eventManager)
    {
        _missionManager = missionManager;
        _vehicleManager = vehicleManager;
        _economyManager = economyManager;
        _eventManager = eventManager;
    }

    public MissionResult StartDeliveryMission(DeliveryMissionData data)
    {
        try
        {
            // Validar requisitos
            if (!ValidateMissionRequirements(data))
                return MissionResult.InvalidRequirements;

            // Obtener vehículo
            var vehicle = _vehicleManager.GetAvailableVehicle(data.VehicleType);
            if (vehicle == null)
                return MissionResult.NoVehicleAvailable;

            // Crear misión
            var mission = _missionManager.CreateDeliveryMission(data);
            
            // Asignar vehículo
            _missionManager.AssignVehicle(mission, vehicle);
            
            // Calcular costes
            var cost = _economyManager.CalculateMissionCost(mission);
            
            // Verificar fondos
            if (!_economyManager.HasEnoughFunds(cost))
                return MissionResult.InsufficientFunds;

            // Iniciar misión
            _economyManager.DeductFunds(cost);
            _missionManager.StartMission(mission);
            _eventManager.NotifyMissionStarted(mission);

            return MissionResult.Success;
        }
        catch (Exception ex)
        {
            _eventManager.NotifyError(ex);
            return MissionResult.Error;
        }
    }

    private bool ValidateMissionRequirements(DeliveryMissionData data)
    {
        return _missionManager.ValidateMissionData(data) &&
               _vehicleManager.HasAvailableVehicle(data.VehicleType) &&
               _economyManager.CanAffordMission(data);
    }
}
```

##### VehicleFacade
```csharp
public class VehicleFacade
{
    private readonly VehicleManager _vehicleManager;
    private readonly MaintenanceManager _maintenanceManager;
    private readonly EconomyManager _economyManager;
    private readonly EventManager _eventManager;

    public VehicleFacade(
        VehicleManager vehicleManager,
        MaintenanceManager maintenanceManager,
        EconomyManager economyManager,
        EventManager eventManager)
    {
        _vehicleManager = vehicleManager;
        _maintenanceManager = maintenanceManager;
        _economyManager = economyManager;
        _eventManager = eventManager;
    }

    public bool PerformMaintenance(Vehicle vehicle, MaintenanceType type)
    {
        try
        {
            // Verificar estado del vehículo
            if (!_vehicleManager.CanPerformMaintenance(vehicle))
                return false;

            // Calcular coste
            var cost = _maintenanceManager.CalculateMaintenanceCost(vehicle, type);
            
            // Verificar fondos
            if (!_economyManager.HasEnoughFunds(cost))
                return false;

            // Realizar mantenimiento
            _economyManager.DeductFunds(cost);
            _maintenanceManager.PerformMaintenance(vehicle, type);
            _vehicleManager.UpdateVehicleStatus(vehicle);
            _eventManager.NotifyMaintenanceCompleted(vehicle, type);

            return true;
        }
        catch (Exception ex)
        {
            _eventManager.NotifyError(ex);
            return false;
        }
    }
}
```

#### Ventajas de la Implementación

##### 1. Simplificación
- Interfaz unificada
- Reducción de complejidad
- Mejor usabilidad
- Código más limpio

##### 2. Encapsulación
- Ocultación de detalles
- Mejor organización
- Separación de responsabilidades
- Mejor mantenibilidad

##### 3. Flexibilidad
- Fácil modificación
- Adaptabilidad
- Extensibilidad
- Mejor testing

#### Beneficios en el Proyecto

##### 1. Desarrollo
- Código más organizado
- Mejor mantenibilidad
- Facilidad de testing
- Mejor documentación

##### 2. Rendimiento
- Optimización de operaciones
- Mejor gestión de recursos
- Reducción de overhead
- Mejor profiling

##### 3. Experiencia de Usuario
- Operaciones más simples
- Mejor feedback
- Mayor consistencia
- Mejor inmersión

#### Consideraciones de Diseño

##### 1. Diseño de Interfaces
- Claridad
- Simplicidad
- Consistencia
- Documentación

##### 2. Implementación
- Código limpio
- Manejo de errores
- Logging
- Testing

##### 3. Mantenimiento
- Documentación
- Revisión de código
- Actualización
- Mejora continua

#### Mejores Prácticas

##### 1. Diseño
- Interfaces claras
- Responsabilidades definidas
- Cohesión
- Acoplamiento bajo

##### 2. Implementación
- Código limpio
- Manejo de errores
- Logging
- Testing

##### 3. Mantenimiento
- Documentación
- Revisión de código
- Actualización
- Mejora continua

### Patrón Decorator en Skyline Logistics

#### Descripción General
El patrón Decorator se ha implementado para permitir la adición dinámica de comportamientos y funcionalidades a los objetos del juego sin modificar su estructura base. Este patrón es fundamental para implementar mejoras, modificadores y efectos especiales de manera flexible y extensible, especialmente en sistemas como vehículos, misiones y eventos.

#### Implementación Principal

##### Decorador Base
```csharp
public abstract class VehicleDecorator : IVehicle
{
    protected readonly IVehicle _vehicle;

    public VehicleDecorator(IVehicle vehicle)
    {
        _vehicle = vehicle;
    }

    public virtual float GetSpeed()
    {
        return _vehicle.GetSpeed();
    }

    public virtual float GetFuelConsumption()
    {
        return _vehicle.GetFuelConsumption();
    }

    public virtual float GetWearRate()
    {
        return _vehicle.GetWearRate();
    }

    public virtual void Update()
    {
        _vehicle.Update();
    }
}
```

#### Casos de Uso

##### 1. Sistema de Mejoras de Vehículos
- **Propósito**: Añadir mejoras y modificadores a vehículos
- **Implementación**:
  * `EngineUpgradeDecorator`: Mejoras de motor
  * `ChassisUpgradeDecorator`: Mejoras de chasis
  * `CabinUpgradeDecorator`: Mejoras de cabina
  * `CargoUpgradeDecorator`: Mejoras de carga

##### 2. Sistema de Misiones
- **Propósito**: Añadir modificadores a misiones
- **Implementación**:
  * `TimeLimitDecorator`: Límites de tiempo
  * `WeatherEffectDecorator`: Efectos climáticos
  * `DifficultyDecorator`: Modificadores de dificultad
  * `RewardDecorator`: Modificadores de recompensas

##### 3. Sistema de Eventos
- **Propósito**: Añadir efectos y modificadores a eventos
- **Implementación**:
  * `WeatherEventDecorator`: Eventos climáticos
  * `TrafficEventDecorator`: Eventos de tráfico
  * `EconomicEventDecorator`: Eventos económicos
  * `SpecialEventDecorator`: Eventos especiales

#### Ejemplos Específicos

##### Mejoras de Vehículos
```csharp
public class EngineUpgradeDecorator : VehicleDecorator
{
    private readonly float _speedMultiplier;
    private readonly float _fuelConsumptionMultiplier;

    public EngineUpgradeDecorator(IVehicle vehicle, float speedMultiplier, float fuelConsumptionMultiplier)
        : base(vehicle)
    {
        _speedMultiplier = speedMultiplier;
        _fuelConsumptionMultiplier = fuelConsumptionMultiplier;
    }

    public override float GetSpeed()
    {
        return base.GetSpeed() * _speedMultiplier;
    }

    public override float GetFuelConsumption()
    {
        return base.GetFuelConsumption() * _fuelConsumptionMultiplier;
    }
}

public class ChassisUpgradeDecorator : VehicleDecorator
{
    private readonly float _wearResistanceMultiplier;
    private readonly float _loadCapacityMultiplier;

    public ChassisUpgradeDecorator(IVehicle vehicle, float wearResistanceMultiplier, float loadCapacityMultiplier)
        : base(vehicle)
    {
        _wearResistanceMultiplier = wearResistanceMultiplier;
        _loadCapacityMultiplier = loadCapacityMultiplier;
    }

    public override float GetWearRate()
    {
        return base.GetWearRate() / _wearResistanceMultiplier;
    }

    public override float GetLoadCapacity()
    {
        return base.GetLoadCapacity() * _loadCapacityMultiplier;
    }
}
```

##### Modificadores de Misiones
```csharp
public class TimeLimitDecorator : MissionDecorator
{
    private readonly float _timeLimit;
    private float _elapsedTime;

    public TimeLimitDecorator(IMission mission, float timeLimit)
        : base(mission)
    {
        _timeLimit = timeLimit;
        _elapsedTime = 0f;
    }

    public override void Update()
    {
        base.Update();
        _elapsedTime += Time.deltaTime;
        
        if (_elapsedTime >= _timeLimit)
        {
            FailMission("Tiempo agotado");
        }
    }

    public override float GetReward()
    {
        var baseReward = base.GetReward();
        var timeBonus = CalculateTimeBonus();
        return baseReward * timeBonus;
    }

    private float CalculateTimeBonus()
    {
        var remainingTime = _timeLimit - _elapsedTime;
        return Mathf.Clamp(remainingTime / _timeLimit, 0.5f, 2f);
    }
}

public class WeatherEffectDecorator : MissionDecorator
{
    private readonly WeatherType _weatherType;
    private readonly float _effectMultiplier;

    public WeatherEffectDecorator(IMission mission, WeatherType weatherType, float effectMultiplier)
        : base(mission)
    {
        _weatherType = weatherType;
        _effectMultiplier = effectMultiplier;
    }

    public override float GetDifficulty()
    {
        var baseDifficulty = base.GetDifficulty();
        return baseDifficulty * _effectMultiplier;
    }

    public override void Update()
    {
        base.Update();
        ApplyWeatherEffects();
    }

    private void ApplyWeatherEffects()
    {
        switch (_weatherType)
        {
            case WeatherType.Rain:
                ApplyRainEffects();
                break;
            case WeatherType.Snow:
                ApplySnowEffects();
                break;
            case WeatherType.Fog:
                ApplyFogEffects();
                break;
        }
    }
}
```

#### Ventajas de la Implementación

##### 1. Flexibilidad
- Adición dinámica de comportamientos
- Combinación de modificadores
- Fácil extensión
- Personalización

##### 2. Mantenibilidad
- Separación de responsabilidades
- Código más organizado
- Mejor testing
- Facilidad de debugging

##### 3. Reutilización
- Componentes reutilizables
- Mejor organización
- Menor duplicación
- Mejor documentación

#### Beneficios en el Proyecto

##### 1. Sistema de Mejoras
- Mejoras dinámicas
- Combinaciones flexibles
- Fácil balanceo
- Mejor experiencia

##### 2. Sistema de Misiones
- Variedad de misiones
- Dificultad adaptable
- Recompensas dinámicas
- Mayor profundidad

##### 3. Sistema de Eventos
- Eventos dinámicos
- Efectos combinables
- Mayor inmersión
- Mejor gameplay

#### Consideraciones de Diseño

##### 1. Diseño de Decoradores
- Interfaces claras
- Responsabilidades definidas
- Orden de decoración
- Manejo de estado

##### 2. Rendimiento
- Optimización de decoradores
- Caching de resultados
- Minimización de overhead
- Profiling

##### 3. Testing
- Testing unitario
- Testing de integración
- Testing de rendimiento
- Testing de combinaciones

#### Mejores Prácticas

##### 1. Diseño
- Interfaces claras
- Decoradores atómicos
- Orden de decoración
- Documentación

##### 2. Implementación
- Código limpio
- Manejo de errores
- Logging
- Testing

##### 3. Mantenimiento
- Documentación
- Revisión de código
- Actualización
- Mejora continua

## Conclusión
Skyline Logistics ofrece una experiencia completa de simulación logística, combinando elementos de estrategia, gestión y simulación. El juego busca ofrecer una experiencia realista y desafiante, donde cada decisión tiene consecuencias en el desarrollo del negocio. La combinación de diferentes modos de juego y niveles de dificultad permite que tanto jugadores casuales como hardcore puedan disfrutar de la experiencia según sus preferencias.

El juego está diseñado para ofrecer una experiencia profunda y gratificante, con múltiples capas de gestión y estrategia que se van desbloqueando a medida que el jugador progresa. La atención al detalle en cada aspecto del juego, desde la gestión de vehículos hasta la economía global, asegura una experiencia inmersiva y desafiante que mantendrá a los jugadores comprometidos durante horas.

 